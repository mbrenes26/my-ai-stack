# 1.1.6 Accessing NumPy Array

This section covers **accessing and manipulating elements** within NumPy arrays—an essential skill for **data analysis** and **machine learning** in Python.

Topics covered:
- Accessing individual elements
- Generating random arrays
- Accessing ranges (slicing)
- Accessing non‑consecutive elements
- Conditional selection

---

## [00:05] Accessing Elements of a NumPy Array

NumPy arrays use **zero‑based indexing**, just like Python lists.  
The first element is at index `0`, the second at index `1`, and so on.

Example:
```python
import numpy as np

arr = np.array([10, 20, 30, 40, 50, 60, 70])
print(arr[0])  # First element: 10
print(arr[6])  # Seventh element: 70
```

---

## [00:10] Generating a Random NumPy Array

You can create a **random NumPy array** using `np.random.randn()`, which generates samples from a **standard normal distribution** (mean 0, std 1).

Example:
```python
rand_arr = np.random.randn(10)  # 10 random values
print(rand_arr)
```

This is useful for **testing algorithms** or **creating mock datasets**.

---

## [01:39] Accessing Ranges of Elements (Slicing)

Slicing works the same way as in Python lists:  
`[start:stop]` → returns elements from `start` to `stop‑1`.

Example:
```python
arr = np.arange(1, 11)  # [1 2 3 4 5 6 7 8 9 10]
subset = arr[4:9]       # Elements at indices 4 to 8
print(subset)           # [5 6 7 8 9]
```

This allows **efficient access** to a subset of data.

---

## [02:25] Accessing Non‑Consecutive Elements

You can use `np.arange()` to **select elements at regular intervals**.

Example:
```python
arr = np.arange(1, 21)  # [1 ... 20]
indices = np.arange(3, 10, 3)  # Indices 3, 6, 9
print(arr[indices])     # [4 7 10]
```

This method is useful for **structured selections** in patterned datasets.

---

## [04:10] Conditional Selection

Conditional selection filters elements that meet a specific condition.

Example:
```python
arr = np.random.randn(10)  # 10 random values
positive_values = arr[arr > 0]  # Only values > 0
print(positive_values)
```

This technique is widely used for:
- **Filtering relevant data**
- **Removing invalid values**
- **Focusing analysis on specific criteria**

---

## Summary

- NumPy arrays use **zero-based indexing** like Python lists.
- **Slicing** allows efficient access to subsets of data.
- **Non-consecutive access** can be achieved using index arrays.
- **Conditional selection** filters data based on logical criteria.
- Random arrays are useful for **testing and simulation** tasks.

---
