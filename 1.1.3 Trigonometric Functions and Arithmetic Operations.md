# 1.1.3 Trigonometric Functions and Arithmetic Operations  
*Using NumPy for Efficient Mathematical Computations*

This section explores how **NumPy**, a powerful Python library for numerical computing, can be used to handle **array manipulation**, **reshaping**, **trigonometric functions**, **exponential/logarithmic calculations**, and **arithmetic operations** efficiently.

---

## **1. Converting One-Dimensional Arrays to Matrices**

Many mathematical operations—such as **matrix multiplication, addition, or subtraction**—require data in a **matrix format**.  

NumPy’s `np.reshape()` function enables:
- Adding or removing dimensions.
- Changing the number of elements across dimensions.
- Preparing arrays for matrix operations.

**Example:**
```python
import numpy as np

arr = np.arange(6)        # 1D array: [0 1 2 3 4 5]
matrix = arr.reshape(2, 3)
print(matrix)
# Output:
# [[0 1 2]
#  [3 4 5]]
```

---

## **2. Creating Arrays with `np.arange()`**

`np.arange(start, stop, step)` generates arrays with evenly spaced values.  
- **Start**: Inclusive starting value.  
- **Stop**: Exclusive ending value.  
- **Step**: Increment between values (default = 1).

**Example:**
```python
arr = np.arange(0, 10, 2)
print(arr)
# Output: [0 2 4 6 8]
```

---

## **3. Reshaping Arrays with `.reshape()`**

Reshaping is essential for converting **1D arrays into matrices** or changing dimensions for compatibility.

**Example:**
```python
arr = np.arange(10)       # 1D array of 10 elements
reshaped = arr.reshape(2, 5)
print(reshaped)
# Output:
# [[0 1 2 3 4]
#  [5 6 7 8 9]]
```

---

## **4. Handling Reshape Errors**

The total number of elements **must match** the product of the new dimensions.  

**Example (error case):**
```python
arr = np.arange(10)
# This will raise ValueError: cannot reshape array of size 10 into shape (2,6)
reshaped = arr.reshape(2, 6)
```

**Tip:**  
Use `len(arr)` or `arr.size` to check element count before reshaping.

---

## **5. Mathematical Operations in NumPy**

NumPy supports **vectorized operations**—optimized for performance—allowing operations on entire arrays at once.

**Example: Trigonometric Functions**
```python
angles = np.array([0, np.pi/2, np.pi])
print(np.sin(angles))  # [0. 1. 0.]
print(np.cos(angles))  # [ 1. 0. -1.]
print(np.tan(angles))  # [ 0. inf  0.]
```
> These functions are **element-wise**, meaning each element is processed independently.

---

## **6. Exponential and Logarithmic Functions**

**Exponentials:**
```python
arr = np.array([1, 2, 3])
print(np.exp(arr))  # [ 2.71828183  7.3890561  20.08553692]
```

**Logarithms:**
```python
print(np.log(arr))    # Natural log (base e)
print(np.log10(arr))  # Logarithm base 10
```

---

## **7. Combining Arrays and Element-Wise Operations**

You can **combine arrays** element by element:
```python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

print(a + b)  # [5 7 9]
print(a - b)  # [-3 -3 -3]
print(a * b)  # [ 4 10 18]
print(a / b)  # [0.25 0.4  0.5 ]
```

---

## **8. Element-Wise Power Operations**

Raise each element of one array to the power of the corresponding element in another:
```python
a = np.array([2, 3, 4])
b = np.array([1, 2, 3])
print(a ** b)  # [ 2  9 64]
```

---

## **9. Key Takeaways**
- **`np.reshape()`** is essential for preparing arrays for matrix operations.  
- Always **match element count** with the target shape when reshaping.  
- NumPy provides **fast, vectorized** trigonometric, exponential, and logarithmic functions.  
- Element-wise arithmetic makes combining and manipulating datasets simple and efficient.  
- These tools are invaluable in **data science**, **engineering**, and **scientific computing**.

---
